\documentclass[a4paper,12pt]{article}

\usepackage[cm]{fullpage}
\usepackage{graphicx}
\usepackage{upgreek}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{csquotes}
\usepackage[dvipsnames]{xcolor}
\usepackage{bm}
\usepackage{url}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{csquotes}
\lstset{ 
  language=Python,
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code 
  keywordstyle=\color{blue},       % keyword style
}

\newcommand{\nn}{\nonumber}
\newcommand{\meeuuw}{{\sc meeuuw~}}
\newcommand{\K}{{\mathbb{K}}}
\newcommand{\G}{{\mathbb{G}}}
\newcommand{\M}{{\mathbb{M}}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{MEEUUW \\ Mantle modelling Early Earth Utrecht University Work in progress}
\author{C. Thieulot} %, A. van den Berg}

\usepackage[style=authoryear,maxnames=1]{biblatex}
\addbibresource{bibliography.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\begin{center}
\includegraphics[width=3cm]{IMAGES/meeuuw}
\end{center}

\tableofcontents

%==============================================================================
\section{Foreword}

I have quite a history of naming codes and regretting my choice afterwards. \meeuuw
is one more in my collection: SoPHa, SPHene, FANTOM, ELEFANT, FLAPS, 
FieldStone\footnote{\url{https://cedrict.github.io/}}.

%==============================================================================
\section{Install process}

The code consists of about two dozens Python files. 
Aside from standard Python modules (numpy, scipy, etc ...) the 
numba\footnote{\url{https://numba.pydata.org/}} package also needs to be 
installed on the machine you are running the code.
The reason for the use of this module is as follows: 
``Numba translates Python functions to optimized machine code at runtime using 
the industry-standard LLVM compiler library. Numba-compiled numerical algorithms 
in Python can approach the speeds of C or FORTRAN.
You don't need to replace the Python interpreter, run a separate compilation step, 
or even have a C/C++ compiler installed. Just apply one of the Numba decorators to your 
Python function, and Numba does the rest.'' [Taken from the numba website]

If numba is not available on your machine, simply delete all occurences of 
\lstinline{@numba.njit} before the functions.

%==============================================================================
\section{Philosophy}

The code is entirely written in Python. The domain is only 2d, in the $xz$-plane.
The geometry of the domain is controlled by the \lstinline{geometry}
parameter which can take four values:
\begin{itemize}
\item \lstinline{box}: A Cartesian domain of size \lstinline{Lx,Ly}
\item \lstinline{half}: 
Half an annulus, parameterised by an inner radius \lstinline{Rinner}, an
outer radius \lstinline{Router} and an opening angle $\theta\in[-\pi/2,\pi/2]$
\item \lstinline{quarter}: Quarter of an annulus, parameterised by an inner radius \lstinline{Rinner}, an
outer radius \lstinline{Router} and an opening angle $\theta\in[0,\pi/2]$
\item \lstinline{eighth}: Eighth of an annulus, parameterised by an inner radius \lstinline{Rinner}, an
outer radius \lstinline{Router} and an opening angle $\theta\in[\pi/4,\pi/2]$
\end{itemize}
An axisymmetric option has been implemented for all four geometries\footnote{Only for the Stokes solver!
no energy equation yet}.

{\color{red} add here figure of all 4 geometries}

There is no adaptive mesh refinement nor mesh 'stretching' at the moment. 
The mesh also does not deform (i.e. no ALE-type algorithm).
The mesh consists of \lstinline{nelx*nelz} elements. In the case of curved domains 
the topology of the mesh is the same but it is curved to conform to the domain boundaries.

The code is not meant to compete with ASPECT or any similar code. It is 
meant to be an educational tool, with MSc or PhD students in mind. 
The interface is simple and flexible so that users can implement
a specific rheology or setup in a few lines of code. 
Inside a \lstinline{experimentX.py} file the user needs to specify the 
necessary parameters (e.g. the resolution, domain size, number of timesteps, etc ...)
and fill in a few template functions:
\begin{lstlisting}  
initial_temperature
assign_boundary_conditions_V
assign_boundary_conditions_T
particle_layout
material_model
gravity_model
\end{lstlisting}  
Run parameters also need to be defined this file, and if not the value in the 
{\tt set\_default\_parameters.py} file apply. 

Because the code is only 2d the memory requirements (aside from the linear solver)
are rather mild with respect with the amount of RAM that laptop or desktop computers now have.
As such I make no attempt at being cautious when it comes to memory use.
This means for example that each particle carries a dozen or so field. 
Likewise the material parameters are projected from the particles onto the 
quadrature points and these projected fields are permanently stored in large arrays.
The rationale is as follows: Lets us assume that we are running a $200\times 200$
element simulation. There are then at least 9 times the number of quadrature points, 
i.e. $\sim 360,000$, each carrying approx. 10 double precision floats (64 bits). 
In total the memory use for these is $360000 \cdot 10 \cdot 64 = 230400000$bits, 
or about 220Mb of memory.

There are at the moment 18 so-called experiments (also called cookbooks in ASPECT)
that either aim at reproducing existing articles results (numerical benchmarks)
or built as setups to be used in class or for research purposes.
Each experiment is entirely contained in its corresponding \lstinline{experimentX.py} file.
The current list of experiments is as follows:
\begin{lstlisting}  
# experiment  0: Blankenbach et al, 1993 - isoviscous convection
# experiment  1: van Keken et al, JGR, 1997 - Rayleigh-Taylor experiment
# experiment  2: Schmeling et al, PEPI 2008 - Newtonian subduction
# experiment  3: Tosi et al, 2015 - visco-plastic convection
# experiment  4: not sure. mantle size convection
# experiment  5: Trompert & Hansen, Nature 1998 - convection w/ plate-like  
# experiment  6: Crameri et al, GJI 2012 (cosine perturbation & plume) 
# experiment  7: ESA workshop
# experiment  8: quarter - sinker
# experiment  9: axisymmetric Mars setup
# experiment 10: axisymmetric 4D dyn Earth benchmark of Stokes sphere
# experiment 11: rising plume 
# experiment 12: hollow earth gravity benchmark 
# experiment 13: sinking block benchmark
# experiment 14: slab detachment (Schmalholz 2011)
# experiment 15: stokes sphere axisymmetric 
# experiment 16: subduction initiation from Matsumoto and Tomoda (1983)
# experiment 17: sinking sphere 512km with sticky air
# experiment 18: sinking sphere unit square with sticky air 
\end{lstlisting}  
The results obtained with the code for these experiments are 
available in the {\tt RESULTS} folder (simply open the {\tt results.pdf} file
-- if it not present use the {\tt lat} script to compile the \LaTeX code)

In order to select one of these experiments, simply open {\tt meeuuw.py}
and edit line 66 which reads \lstinline{experiment=X}.

In order to run the code, simply then type the following in the terminal:
\begin{verbatim}
python3 meeuuw.py
\end{verbatim}
Note that a script carrying this also exists and can be executed as follows:
\begin{verbatim}
./run
\end{verbatim}

The code will then run and will produce {\it a lot} of information 
while running in the terminal. If you wish to keep this information 
you can redirect the screen output to a file as follows for example:
\begin{verbatim}
python3 meeuuw.py > screen_output.text
\end{verbatim}
The code also generates {\tt .ascii} files (to be plotted with gnuplot for example)
and {\tt .vtu} files to be opened with ParaView. All are placed automatically 
in the {\tt OUTPUT} folder.

After a simulation, if results are to be discarded, and before running a new 
model, it is recommended to remove all results by running the following script:
\begin{verbatim}
./cleandata
\end{verbatim}

\newpage
%==============================================================================
\section{Numerical methods}

%-----------------------------------
\subsection{Finite Element Method}

The Stokes equations are discretised by means of the Finite Element Method (FEM).
As explained in \textcite{thba22} and \textcite{thba25}, there are many 
so-called element pairs for the velocity and pressure spaces.  
The \meeuuw code relies
on quadrilateral Taylor-Hood elements only, i.e. $Q_2 \times Q_1$.
The energy equation relies on $Q_2$ elements for the temperature.
The FEM formulation of these equations is explained in the FieldStone 
manual\footnote{\url{https://cedrict.github.io/}} and plenty of 
textbooks.

The discretisation of the Stokes equations (mass and momentum equation)
yields the following linear system:
\[
\left(\begin{array}{cc}
\K & \G \\
\G^T & 0
\end{array}
\right)
\cdot
\left(
\begin{array}{c}
\vec{\cal V} \\
\vec{\cal P} 
\end{array}
\right)
=
\left(
\begin{array}{c}
\vec{f} \\
\vec{h} 
\end{array}
\right)
\]
At the moment the whole matrix and right hand side is built and stored in the 
following arrays:
\begin{lstlisting}
bignb_V=nel*( (m_V*ndof_V)**2 + 2*(m_V*ndof_V*m_P) )
II_V=np.zeros(bignb_V,dtype=np.int32)    
JJ_V=np.zeros(bignb_V,dtype=np.int32)    
VV_T=np.zeros(bignb,dtype=np.float64)    
rhs=np.zeros(Nfem_T,dtype=np.float64)
\end{lstlisting}

while the discretisation of the energy equation yields
\[
\left(\M + \frac12 (\K_a + \K_d) \delta t \right) \cdot \vec{\cal T}^{k+1}
= \left(\M - \frac12 (\K_a + \K_d) \delta t \right) \cdot \vec{\cal T}^k + \vec{H}
\]
where $\M$ is the mass matrix, $\K_a$ is the advection matrix, 
$\K_d$ is the diffusion matrix.

The fully assembled matrix and right hand side are stored in the following arrays: 
\begin{lstlisting}
bignb_T=nel*m_T**2 
II_T=np.zeros(bignb_T,dtype=np.int32)    
JJ_T=np.zeros(bignb_T,dtype=np.int32)    
VV_T=np.zeros(bignb,dtype=np.float64)    
rhs=np.zeros(Nfem_T,dtype=np.float64)
\end{lstlisting}



At the moment there is no stabilisation scheme implemented which can help 
with highly advective problems (high Peclet number).


%-----------------------------------
\subsection{Particle-In-Cell method}


The code relies on the Particle-in-Cell method to track compositional fields.
This is not the only method used in geodynamics, see for example 
the textbooks by Gerya, or by Tackley \& Ismael-Zaddeh.
All arrays bearing the name \lstinline{swarm_xxxx} are \lstinline{nparticle} long.
Note that the total number of particles is constant (no addition, no deletion).
\lstinline{swarm_x}, \lstinline{swarm_z} contain all their Cartesian coordinates, 
\lstinline{swarm_rad}, \lstinline{swarm_theta} contain all their polar coordinates, 
\lstinline{swarm_u}, \lstinline{swarm_w} contain all their velocities, 
\lstinline{swarm_r}, \lstinline{swarm_t} contain all their local coordinates ($r,t\in[-1:1]$),
\lstinline{swarm_iel} contains their parent element number, etc ...
The particles are advected by means of either Runge-Kutta 1st, 2nd and 4th order in space
algorithms (as controlled by the global parameter \lstinline{RKorder}).
Note that \lstinline{RKorder} can also be set to -1 {\color{red} explain}.
The global parameter \lstinline{nparticle_per_dim} controls the initial number 
of particles per element and the total number of particles:
\begin{lstlisting}
nparticle_per_element=nparticle_per_dim**2
nparticle=nel*nparticle_per_element
\end{lstlisting}
The initial type of spatial distribution of the particles is controlled 
by the parameter \lstinline{particle_distribution} which can take 4 
values: 
\begin{enumerate}
\item random: \lstinline{nparticle_per_element} particles are generated at random inside the element
using the local coordinates and an isoparametric mapping; 
\item regular: the particles are arranged in an \lstinline{nparticle_per_dim*nparticle_per_dim} array;
\item Poisson disc sampling\footnote{\url{https://www.jasondavies.com/poisson-disc/}}. At the moment this is only 
available for the 'box' geometry.
\item pseudo-random: this is similar to 2, but a small perturbation is added to the positions.
\end{enumerate}

Fields can be easily added to particles depending on the needs of a given experiment, for example 
\lstinline{swarm_F} tracks the depletion.

The core of the Particle-In-Cell method that is implemented is as follows. 
At the beginning of each time step the temperature, pressure and strain rate 
is interpolated on a particle.
The so-called \lstinline{material_model} is then called and returns the following 
particle fields: \lstinline{swarm_rho,swarm_eta,swarm_hcond,swarm_hcapa,swarm_hprod}.

The fields carried by the particle must then be projected where 
they are needed for the Finite Element matrix building algorithm, i.e. 
the Gauss quadrature points (typically and array of $3\times 3$ points inside
each element).

There are multiple options, controlled by the 
\lstinline{particle_rho_projection} and \lstinline{particle_eta_projection}
parameters:
\begin{itemize}
\item \lstinline{'elemental}
\item \lstinline{'nodal'}
\item \lstinline{'least_squares_P1'} -- see subsection below 
\item \lstinline{'least_squares_Q1'} -- see subsection below 
\end{itemize}


The fields are then projected onto the mesh nodes, the resulting fields belonging 
to the $Q_1$ space. An arithmetic average is used for the 
heat capacity, heat conductivity, heat production and density, while the user may choose 
between and arithmetic, geometric, or harmonic averaging for the viscosity.



Finally these nodal quantities are interpolated onto the quadrature points and these 
values will be used to build the FE matrices for the Stokes and/or energy equations.

%------------------------------------
\subsubsection{Least square algorithms}

One could think that 
with high(er) order elements optimal convergence is unlikely to be reached 
if viscosity (and density) are assumed to be constant inside each element (see  
\textcite{galb19}). 
One could therefore use the least-square method to arrive at 
a functional representation of the field inside the element which is as 
close as possible (in the least-squares sense, then) to the particle-based field. 

\textcite{thmk14} use the $Q_2P_{-1}$ element and introduce an 
element-wise interpolation
scheme based on a least squares fitting of the particle properties and choose the functional to 
be a linear function to match the pressure space. 
They define the error $\epsilon$ such that 
\[
\epsilon^2 = \sum_{i=1}^n ( \tilde{f}(x_i,z_i)-f_i)^2
\]
with $\tilde{f}(x,z)=a+bx+cz$ and proceed to  
look for the minimum of $\epsilon^2$, i.e. $\vec\nabla(\epsilon^2)=0$ in the $\{a,b,c\}$ space:
\begin{eqnarray}
0=\frac{\partial \epsilon^2}{\partial a} 
&=& 2\sum\limits_i ( \tilde{f}(x_i,z_i)-f_i) \nn\\
&=& 2\sum\limits_i ( a + bx_i +cz_i -f_i) \nn\\
&=& 2 \left[ a \sum\limits_i 1 + b \sum\limits_i x_i + c \sum z_i - \sum\limits_i f_i \right] \nn\\
0=\frac{\partial \epsilon^2}{\partial b} &=& 2\sum\limits_i ( \tilde{f}(x_i,z_i)-f_i) x_i \nn\\
&=& 2\sum\limits_i ( a + bx_i +cz_i -f_i) x_i \nn\\
&=& 2 \left[ a \sum\limits_i x_i  + b \sum\limits_i x_i^2 + c \sum x_i z_i - \sum\limits_i x_i f_i \right]\nn\\
0=\frac{\partial \epsilon^2}{\partial c} &=& 2\sum\limits_i ( \tilde{f}(x_i,z_i)-f_i) z_i \nn\\ 
&=& 2\sum\limits_i ( a + bx_i +cz_i -f_i) z_i \nn\\
&=& 2 \left[ a \sum\limits_i z_i + b \sum\limits_i x_i z_i + c \sum z_i^2 - \sum\limits_i z_if_i \right] \nn
\end{eqnarray}
so 
\[
\left( 
\begin{array}{ccc}
\sum\limits_i 1 & \sum\limits_i x_i & \sum\limits_i z_i \\
\sum\limits_i x_i & \sum\limits_i x_i^2 & \sum\limits_i x_iz_i \\
\sum\limits_i z_i & \sum\limits_i x_i z_i & \sum\limits_i z_i^2 
\end{array}
\right)
\cdot
\left(
\begin{array}{c}
a\\ \\
b\\ \\
c
\end{array}
\right)
=
\left(
\begin{array}{c}
\sum\limits_i f_i \\
\sum\limits_i x_i f_i \\
\sum\limits_i z_i f_i 
\end{array}
\right)
\]
This method can trivially be extended to three dimensions. It must also be noted that 
it is not cheap: for each element the matrix and rhs above must be formed and the system 
solved for $a,b,c$. 


We could also then decide to use a bi-linear function $\tilde{f}$, i.e.
\[
\tilde{f}(x,z)=a+bx+cz+dxz
\]
which lies in the $Q_1$ space of Taylor-Hood quadrilateral elements. In this case the error is 
\[
\epsilon^2 
= \sum_{i=1}^n ( \tilde{f}(x_i,z_i)-f_i)^2
= \sum_{i=1}^n (a+bx_i+cz_i + dx_iz_i -f_i)^2
\]
and one has to solve a $4\times 4$ system this time:
\[
\left( 
\begin{array}{cccc}
\sum\limits_i 1 & \sum\limits_i x_i & \sum\limits_i z_i & \sum\limits_i x_iz_i\\
\sum\limits_i x_i & \sum\limits_i x_i^2 & \sum\limits_i x_iz_i & \sum\limits_i x_i^2 z_i\\
\sum\limits_i z_i & \sum\limits_i x_i z_i & \sum\limits_i z_i^2 & \sum\limits_i x_iz_i^2\\ 
\sum\limits_i x_iz_i & \sum\limits_i x_i z_i & \sum\limits_i z_i^2 & \sum\limits_i x_i^2z_i^2  
\end{array}
\right)
\cdot
\left(
\begin{array}{c}
a\\
b\\
c\\
d
\end{array}
\right)
=
\left(
\begin{array}{c}
\sum\limits_i f_i \\
\sum\limits_i x_i f_i \\
\sum\limits_i z_i f_i \\
\sum\limits_i x_i z_i f_i 
\end{array}
\right)
\]
which we write ${\bm A}\cdot \vec{c}={\bm b}$. Note that 
the matrix ${\bm A}$ is symmetric.
We see that this is a potentially numerically problematic equation. 
Distances/coordinates in geodynamic calculations are of the order of 100-1000\si{\km} and 
viscosities are between $10^{19}$ and $10^{26}$\si{\pascal\second}. 
The matrix would contain very large terms, which may compromise the accuracy of the system solve.

A typical 'fix' for some of these numerical problems is as follows. One postulates that 
over element $e$ the field $\tilde{f}$ is given (in the $P_1$ case) by 
\[
\tilde{f}(x,z)=a+b(x-x_e)+c(z-z_e)+d(x-x_e)(z-z_e)
\]
where $x_e,z_e$ are the coordinates of the element center.
This means that all the terms containing coordinates $x$ and $y$ in the matrix 
are all about the same magnitude.
However this may not be enough. If the particle distribution in the element is 
not homogenous enough then the matrix may be ill-conditioned.


Once this linear system (or the previous one) has been solved we have obtained the coefficients $a,b,c(,d)$ 
which allow us to compute $\tilde{f}$ anywhere inside the element, and especially 
at the quadrature points. Once these coefficients have been obtained one can compute $\tilde{f}$
anywhere in the element, and in particular at the quadrature points.  

Using a different (bi)linear function $\tilde{f}$ for each element 
means that it is likely to be discontinuous 
from one element to another in regions of high gradients. 

There is however one drawback with this approach (linear or bi-linear alike):
in the areas of steep gradients the computed coefficients can be such that 
the function $\tilde{f}$ evaluated on a quadrature point 
is negative  which 1) would be wrong but not numerically 
dramatic for density, 2) would be wrong and physically and numerically 
problematic for viscosity (a viscosity cannot be negative, and this would 
automatically destroy the SPD nature of the viscous block of the Stokes matrix).

This problem is discussed in \textcite{thmk14} in Section 3.2.1 and they 
call this "Over- and Under-shooting". A simple (iterative) 
fix is then designed which insures that the computed value is within user-defined 
acceptable bounds. 
They write:
\begin{displayquote}
``
If $f(x,z)$ possesses a jump inside an element, the value $\tilde{f}$ 
at both the quadrature points and the nodes of 
might be significantly larger or smaller than the
maximum or minimum value of the same physical
property on the particles. This over-shooting or
under-shooting is not desirable as it might have a
severe impact on the solution. In extreme cases, even
unphysical results are possible (e.g., negative viscosities). 
In our implementation of the linear least
squares interpolation, we, therefore, check each
element for over-shooting and under-shooting by
inspecting the value of $\tilde{f}$ at the nodes of each
element. We choose to use the nodal values as those
to represent the locations where over-shooting and
under-shooting have the biggest effect. Additionally,
as we expect both the density and viscosity field to be
continuous, the values at the nodes should not exhibit
jumps that are too large. The nodal values that exhibit
smaller/larger values than the minimum/maximum
values stored on the particles are then set to the
respective minimum and maximum values. We then
compute the new coefficients of the linear regression
plane using the updated nodal values only. This
procedure is repeated until no nodal values are over-
shooting or under-shooting. The values at the quadrature 
points use the corrected coefficients. For better
convergence of this iterative algorithm, we slightly
relax the upper and lower limits and allow nodal
values to over-/under-shoot by 1\% of the respective
maximum/minimum value.
''
\end{displayquote}
{\color{red} to do ?}

This is also mentioned in \cite{galb19} but the authors 
explain that this problem was not encountered in the context of the publication.

For the time being there is a limiter implemented for the $P_1$ case ({\color{red}
I need to ask Gerry where it comes from - ref?}) and node for the $Q_1$ case.


\underline{Remark:} One could consider the above least-square approach with $\tilde{f}=a$, i.e. $\tilde{f}$ is
a zero-th order polynomial. In this case
\[
\epsilon^2 = \sum_{i=1}^n ( \tilde{f}(x_i,z_i)-f_i)^2 = \sum_{i=1}^n (a-f_i)^2 
\]
The gradient becomes
\[
\vec\nabla(\epsilon^2)= \frac{d \epsilon^2}{da} = \sum_{i=1}^n 2 (a-f_i) = 0
\]
or $a=\frac1n \sum_i f_i$. We here recover the arithmetic averaging!

















\newpage
%==============================================================================
\section{Code structure}

\verbatiminput{structure}

\newpage
%==============================================================================
\section{Nomenclature}

All calculations take place in the $x-z$ plane.
The corresponding reduced/local coordinates are then $r,t$.
There is a single mesh with \lstinline{nel} elements, 
but the velocity is in the space $Q_2$ while the pressure is the space $Q_1$.
There are then \lstinline{(2*nelx+1)*(2*nelz+1)} velocity nodes
and \lstinline{(nelx+1)*(nelz+1)} pressure nodes.
All quantities ending in \lstinline{_V} (e.g. \lstinline{nn_V}, \lstinline{m_V}, \lstinline{x_V,y_V})
are related to/defined on the velocity nodes while those ending in 
\lstinline{_P} (e.g. \lstinline{nn_P}, \lstinline{m_P}, \lstinline{x_P,y_P})
are related to/defined on the pressure nodes. 

\begin{center}
\includegraphics[width=8cm]{IMAGES/q2q1setup} % borrowed from stone 18
\end{center}


The internal numbering of the velocity nodes is as follows:

\input{tikz/tikz_q22d}

while the numbering of the pressure nodes is as follows:

\input{tikz/tikz_q12d}

For the spherical coordinates we adopt the following notations for the angles
$\theta$ and $\phi$:

\begin{center}
\includegraphics[width=3cm]{IMAGES/sphcoord}
\end{center}


\subsection{Mesh related parameters}

\begin{itemize}
\item \lstinline{nelx,nelz}: number of elements in each direction
\item \lstinline{nnx,nnz}: number of V nodes in each direction
\item \lstinline{nel}: number of elements
\item \lstinline{nn_V}: number of velocity nodes
\item \lstinline{nn_P}: number of pressure nodes
\item \lstinline{ndof_V_el}: number of V dofs per element (=18)
\item \lstinline{m_V}: number of velocity nodes per element (=9)
\item \lstinline{m_P}: number of pressure nodes per element (=4)
\item \lstinline{m_T}: number of temperature nodes per element (=9)
\item \lstinline{hx,hz}: size of an element
\item \lstinline{Nfem_V}: number of velocity degrees of freedom
\item \lstinline{Nfem_P}: number of pressure degrees of freedom
\item \lstinline{Nfem_T}: number of temperature degrees of freedom
\item \lstinline{Nfem}: total number of degrees of freedom (Stokes eqs) 
\item \lstinline{vrms}: root mean square velocity $\upnu_{rms}$
\end{itemize}

\subsection{Mesh related arrays}

\begin{itemize}
\item \lstinline{exx_n,ezz_n,exz_n}: strain rate tensor ${\bm \varepsilon}(\vec\upnu)$ on the nodes
\item \lstinline{exx_e,ezz_e,exz_e}: strain rate tensor ${\bm \varepsilon}(\vec\upnu)$ in the element center
\item \lstinline{dxx_n,dzz_n,dxz_n}: deviatoric strain rate tensor ${\bm \varepsilon}^d(\vec\upnu)$ on the nodes
\item \lstinline{tauxx_n,tauzz_n,tauxz_n}: deviatoric stress ${\bm \tau}$ on the nodes
\item \lstinline{sigmaxx_n,sigmazz_n,sigmaxz_n}: full stress tensor ${\bm \sigma}$ on the nodes
\item \lstinline{T}: temperature array
\item \lstinline{p}: pressure field (on $Q_1$ mesh)
\item \lstinline{q}: pressure field (on $Q_2$ mesh)
\item \lstinline{u,w}:  velocity components arrays
\item \lstinline{x_V,y_V}: coordinates arrays of velocity nodes
\item \lstinline{x_P,y_P}: coordinates arrays of pressure nodes
\item \lstinline{icon_V}: connectivity array for velocity nodes
\item \lstinline{icon_P}: connectivity array for pressure nodes
\item \lstinline{bc_fix_V, bc_val_V}: boundary conditions arrays for velocity
\item \lstinline{bc_fix_T, bc_val_T}: boundary conditions arrays for temperature
\item \lstinline{N_V, dNdr_V, dNdt_V, dNdx_V, dNdz_V}: velocity basis functions and derivatives
\item \lstinline{N_P}: pressure basis functions
\item \lstinline{qx_n, qz_n}: nodal heat flux component
\item \lstinline{II_V, JJ_V, VV_V}: arrays to store Stokes FEM matrix
\item \lstinline{II_T, JJ_T, VV_T}: arrays to store energy FEM matrix
\item \lstinline{r_V, s_V}: arrays of size \lstinline{m_V} containing red coords of V nodes
\item \lstinline{rad_V, theta_V}: polar coordinates of V nodes, i.e. $\theta_V\in[-\pi/2,\pi/2]$
\item \lstinline{rad_P, theta_P}: polar coordinates of P nodes
\end{itemize}

\subsection{Particle swarm related arrays and parameters}

\begin{itemize}
\item \lstinline{swarm_x}: 
\item \lstinline{swarm_z}:
\item \lstinline{swarm_rho}:
\item \lstinline{swarm_eta}:
\item \lstinline{swarm_T}:
\item \lstinline{swarm_p}:
\item \lstinline{swarm_F}:
\item \lstinline{swarm_sst}:
\item \lstinline{swarm_exx}:
\item \lstinline{swarm_ezz}:
\item \lstinline{swarm_exz}:
\item \lstinline{swarm_iel}:
\item \lstinline{swarm_rad}:
\item \lstinline{swarm_theta}:
\item \lstinline{swarm_u}:
\item \lstinline{swarm_w}:
\item \lstinline{swarm_r}:
\item \lstinline{swarm_t}:
\item \lstinline{swarm_strain}:
\item \lstinline{swarm_active}:
\item \lstinline{swarm_hcond}:
\item \lstinline{swarm_hcapa}:
\item \lstinline{swarm_hprod}:
\end{itemize}

\subsection{Quadrature related arrays and parameters}

\begin{itemize}
\item \lstinline{nq_per_element=nq_per_dim**ndim}
\item \lstinline{nq=nq_per_element*nel}
\item \lstinline{xq,zq}
\item \lstinline{rhoq}
\item \lstinline{etaq}
\item \lstinline{Tq}
\item \lstinline{hcondq}
\item \lstinline{hcapaq}
\item \lstinline{hprodq}
\item \lstinline{dpdxq,dpdzq}
\item \lstinline{gxq,gzq}
\item \lstinline{exxq,ezzq,exzq}
\item \lstinline{JxWq}
\item \lstinline{jcbi00q,jcbi01q,jcbi10q,jcbi11q}
\item \lstinline{nqperdim,qcoords,qweights}
\end{itemize}


\newpage
%==============================================================================
\section{Conversions between coordinate systems}

%-------------------
\subsection{vectors}

\subsubsection{Polar coordinates (2d)}

The equations and the code are formulated in Cartesian coordinates. 
However, when an annulus-like geometry is used one may wish to look at 
certain quantities expressed in polar coordinates.
For example, the velocity $\vec\upnu=(u,w)$ is then given by
\begin{align}
\upnu_r &=  u \cos\theta + w \sin\theta \\
\upnu_\theta &= -u \sin\theta + w \cos\theta
\end{align}

\subsubsection{Spherical coordinates (3d)}

The velocity in spherical coordinates is given by
\begin{eqnarray}
v_r      &=&  u \sin \theta  \cos \phi  + v \sin\theta \sin \phi + w \cos\theta \\
v_\theta &=&  u \cos\theta\cos\phi + v \cos\theta\sin\phi -w \sin\theta   \\
v_\phi   &=& -u \sin\phi  + v \cos\phi  
\end{eqnarray}
We will be using these expressions only when the axisymmetric mode is activated, 
since in fact the problem is in fact 3d.
Because of the symmetry we expect $v_\phi=0$ and $\phi=0$ sine we compute in the $xz$ plane,
so that in the end we have the following expression: 
\begin{eqnarray}
v_r      &=&  u \sin \theta  + w \cos\theta \\
v_\theta &=&  u \cos\theta  -w \sin\theta   
\end{eqnarray}
One thing to be aware of, is the fact that the $\theta_{sph}$ angle of spherical harmonics
is measured from the vertical axis, while the theta angle $\theta_p$ is measured from the horizontal 
axis in polar coordinates, i.e. $\theta_{sph}=\frac{\pi}{2}-\theta_{pol}$ in the 
$x>0$ half-plane where calculations take place. 
\begin{center}
\includegraphics[width=3cm,angle=-90]{IMAGES/coords}
\end{center}
The \lstinline{theta_V} quantity in the code corresponds to the polar coordinates angle $\theta_p$.

Then
\begin{eqnarray}
v_r      
&=&  u \sin (\frac{\pi}{2}-\theta_p)  + w \cos (\frac{\pi}{2}-   \theta_p) 
=  u \cos \theta_p  + w \sin\theta_p \\
v_\theta 
&=&  u \cos(\frac{\pi}{2}-\theta_p)  -w \sin(\frac{\pi}{2}-\theta_p   ) 
=  u \sin \theta_p  -w \cos \theta_p   
\end{eqnarray}

This translates as follows:
\begin{lstlisting}
if geometry=='quarter' or geometry=='half' or geometry=='eighth':
   if axisymmetric:
      vr=u*np.cos(theta_V)+v*np.sin(theta_V)
      vt=u*np.sin(theta_V)-v*np.cos(theta_V)
   else:
      vr=u*np.cos(theta_V)+v*np.sin(theta_V)
      vt=-u*np.sin(theta_V)+v*np.cos(theta_V)
\end{lstlisting}


%-------------------
\subsection{tensors}

%................................
\subsubsection{Polar coordinates}

\begin{eqnarray}
{\bm T}_{\rm polar}
&=&
\left(\begin{array}{cc}
T_{rr}       & T_{r\theta}     \\ 
T_{\theta r} & T_{\theta\theta}
\end{array}\right) \nn\\ 
&=&
\left(\begin{array}{cc}
 \cos \theta&\sin \theta \\
-\sin \theta&\cos \theta \\
\end{array}\right)
\cdot
\left(\begin{array}{cc}
T_{xx} & T_{xy}  \\
T_{yx} & T_{yy} 
\end{array}\right)
\cdot
\left(\begin{array}{cc}
\cos \theta & -\sin \theta \\
\sin \theta &  \cos \theta \\
\end{array}\right) 
\nn\\
&=&
\left(\begin{array}{cc}
 \cos \theta&\sin \theta \\
-\sin \theta&\cos \theta \\
\end{array}\right)
\cdot
\left(
\begin{array}{cc}
T_{xx} \cos\theta  + T_{xy} \sin\theta & -T_{xx} \sin\theta + T_{xy} \cos\theta \\ 
T_{yx} \cos\theta  + T_{yy} \sin\theta & -T_{yx} \sin\theta + T_{yy} \cos\theta 
\end{array}
\right) \nn\\
&=& 
\left(\begin{array}{ccc}
T_{xx} c^2_\theta  + T_{xy} s_\theta c_\theta 
+T_{yx} s_\theta c_\theta  + T_{yy} s^2_\theta & 
-T_{xx} s_\theta c_\theta + T_{xy} c^2_\theta
-T_{yx} s^2_\theta + T_{yy} s_\theta c_\theta &
 \\ \\
-T_{xx} s_\theta c_\theta  - T_{xy} s^2_\theta 
+ T_{yx} c^2_\theta  + T_{yy} s_\theta c_\theta &  
T_{xx} s^2_\theta - T_{xy} s_\theta c_\theta 
-T_{yx} s_\theta c_\theta + T_{yy} c^2_\theta
\end{array}
\right) \nn\\
&=& 
\left(\begin{array}{cc}
T_{xx} c^2_\theta  + 2T_{xy} s_\theta c_\theta + T_{yy} s^2_\theta & 
(T_{yy}-T_{xx}) s_\theta c_\theta + T_{xy} (c^2_\theta - s^2_\theta)   \\ 
\\
(T_{yy}-T_{xx}) s_\theta c_\theta  + T_{xy} (c^2_\theta -s^2_\theta )  &  
T_{xx} s^2_\theta - 2T_{xy} s_\theta c_\theta + T_{yy} c^2_\theta  
\end{array}
\right) \nn
\end{eqnarray}
where we have assumed that the tensor ${\bm T}$ is symmetric at some point.
Note also that the trace of ${\bm T}_{\rm polar}$ is 
\[
Tr[{\bm T}_{\rm polar}] = T_{xx} c^2_\theta  + 2T_{xy} s_\theta c_\theta + T_{yy} s^2_\theta
+ T_{xx} s^2_\theta - 2T_{xy} s_\theta c_\theta + T_{yy} c^2_\theta 
= T_{xx} + T_{zz}
\]
Indeed, the trace of a tensor is an invariant.

Finally we can also use $\sin 2x = 2 \sin x \cos x$ and $\cos 2x = \cos^2 x -\sin^2 x$ 
to arrive at
\begin{eqnarray}
{\bm T}_{\rm polar}
&=&
\left(\begin{array}{cc}
T_{rr}       & T_{r\theta}     \\ 
T_{\theta r} & T_{\theta\theta}
\end{array}\right) \nn\\
&=& 
\left(\begin{array}{cc}
T_{xx} \cos^2 \theta  + T_{xy} \sin 2\theta + T_{yy} \sin^2 \theta & 
\frac12(T_{yy}-T_{xx}) \sin 2\theta  + T_{xy} \cos 2\theta    \\ 
\\
\frac12 (T_{yy}-T_{xx}) \sin 2\theta  + T_{xy} \cos 2\theta   &  
T_{xx} \sin^2 \theta - T_{xy} \sin 2\theta + T_{yy} \cos^2 \theta  
\end{array}
\right) \nn
\end{eqnarray}
or,
\begin{eqnarray}
T_{rr} &=& T_{xx} \cos^2 \theta  + T_{xy} \sin 2\theta + T_{yy} \sin^2 \theta \\ 
T_{\theta\theta} &=& T_{xx} \sin^2 \theta - T_{xy} \sin 2\theta + T_{yy} \cos^2 \theta \\
T_{r\theta} &=& \frac12(T_{yy}-T_{xx}) \sin 2\theta  + T_{xy} \cos 2\theta 
\end{eqnarray}


This translates as follows {\color{red} modify code !}:
\begin{lstlisting}
def convert_tensor_to_polar_coords(theta,Txx,Tyy,Txy):
Trr=Txx*(np.cos(theta))**2 +2*Txy*np.sin(theta)*np.cos(theta) +Tyy*(np.sin(theta))**2
Ttt=Txx*(np.sin(theta))**2 -2*Txy*np.sin(theta)*np.cos(theta) +Tyy*(np.cos(theta))**2
Trt=(Tyy-Txx)*np.sin(theta)*np.cos(theta)+Txy*((np.cos(theta))**2-(np.sin(theta))**2)
return Trr,Ttt,Trt
\end{lstlisting}


\newpage
%....................................
\subsubsection{Spherical coordinates}

In order to compute the dynamic topography we will need $\sigma_{rr}$, 
which in fact will require $\dot{\varepsilon}_{rr}$. This means that 
having obtained the strain rate tensor in Cartesian coordinates we must 
rewrite it in spherical coordinates with the following conventions:

\begin{center}
\includegraphics[width=3cm]{IMAGES/sphcoord}
\end{center}

We have {\color{red} FIND SOURCE!!}
\begin{eqnarray}
{\bm T}_{\rm spherical}&=&
\left(
\begin{array}{ccc}
T_{rr}       & T_{r\theta}      & T_{r\phi} \\
T_{\theta r} & T_{\theta\theta} & T_{\theta\phi} \\
T_{\phi r}   & T_{\phi \theta}  & T_{\phi\phi}
\end{array}
\right) \nn\\
&=&
\left(
\begin{array}{ccc}
\sin\theta \cos\phi & \sin\theta \sin\phi & \cos\theta \\
\cos\theta \cos\phi & \cos\theta \sin\phi & -\sin\theta \\
-\sin\phi & \cos\phi & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
T_{xx} & T_{xy} & T_{xz} \\
T_{yx} & T_{yy} & T_{yz} \\
T_{zx} & T_{zy} & T_{zz} 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
\sin\theta\cos\phi & \cos\theta\cos\phi & -\sin\phi \\
\sin\theta\sin\phi & \cos\theta\sin\phi & \cos\phi \\
\cos\theta & -\sin\theta & 0
\end{array}
\right) 
\nn
\end{eqnarray}
In our case, calculations take place in the 
$(x,z)$-plane so we have $\phi=0$ and the equation above 
becomes
\[
\left(
\begin{array}{ccc}
T_{rr}       & T_{r\theta}      & T_{r\phi} \\
T_{\theta r} & T_{\theta\theta} & T_{\theta\phi} \\
T_{\phi r}   & T_{\phi \theta}  & T_{\phi\phi}
\end{array}
\right)
=
\left(
\begin{array}{ccc}
\sin\theta  & 0 & \cos\theta \\
\cos\theta  & 0 & -\sin\theta \\
0 & 1 & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
T_{xx} & T_{xy} & T_{xz} \\
T_{yx} & T_{yy} & T_{yz} \\
T_{zx} & T_{zy} & T_{zz} 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1 \\
\cos\theta & -\sin\theta & 0
\end{array}
\right)
\]
We define $c_\theta=\cos\theta$, $s_\theta=\sin\theta$ so that 
the following calculations fit on the page:
\begin{eqnarray}
&&\left(
\begin{array}{ccc}
T_{rr}       & T_{r\theta}      & T_{r\phi} \\
T_{\theta r} & T_{\theta\theta} & T_{\theta\phi} \\
T_{\phi r}   & T_{\phi \theta}  & T_{\phi\phi}
\end{array}
\right) \nn\\
&=&
\left(
\begin{array}{ccc}
s_\theta  & 0 & c_\theta \\
c_\theta  & 0 & -s_\theta \\
0 & 1 & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
T_{xx} & T_{xy} & T_{xz} \\
T_{yx} & T_{yy} & T_{yz} \\
T_{zx} & T_{zy} & T_{zz} 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
s_\theta & c_\theta & 0 \\
0 & 0 & 1 \\
c_\theta & -s_\theta & 0
\end{array}
\right)
\nn\\
&=&
\left(
\begin{array}{ccc}
s_\theta  & 0 & c_\theta \\
c_\theta  & 0 & -s_\theta \\
0 & 1 & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
T_{xx} s_\theta  + T_{xz}c_\theta & T_{xx} c_\theta  - T_{xz}s_\theta  & T_{xy} \\
T_{yx} s_\theta  + T_{yz}c_\theta & T_{yx} c_\theta  - T_{yz}s_\theta  & T_{yy} \\
T_{zx} s_\theta  + T_{zz}c_\theta & T_{zx} c_\theta  - T_{zz}s_\theta  & T_{zy} 
\end{array}
\right)
\nn\\
&=&
\left(
\begin{array}{ccc}
T_{xx} s^2_\theta  + T_{xz}s_\theta c_\theta + T_{zx} s_\theta c_\theta  + T_{zz}c^2_\theta &
T_{xx} s_\theta c_\theta  - T_{xz}s^2_\theta      +    T_{zx} c^2_\theta  - T_{zz}s_\theta  c_\theta &
T_{xy} s_\theta  + T_{zy} c_\theta 
\\
T_{xx} s_\theta c_\theta + T_{xz}c^2_\theta - T_{zx} s^2_\theta  - T_{zz}s_\theta c_\theta &
T_{xx} c^2_\theta  - T_{xz}s_\theta c_\theta - T_{zx} s_\theta c_\theta  + T_{zz}s^2_\theta & 
T_{xy} c_\theta  - T_{zy}  s_\theta 
\\ 
T_{yx} s_\theta  + T_{yz}c_\theta & T_{yx} c_\theta  - T_{yz}s_\theta  & T_{yy}
\end{array}
\right) \nn
\end{eqnarray}

Using 
the fact that ${\bm T}$ is a symmetric tensor:
\begin{equation}
\left(
\begin{array}{ccc}
T_{rr}       & T_{r\theta}      & T_{r\phi} \\
T_{\theta r} & T_{\theta\theta} & T_{\theta\phi} \\
T_{\phi r}   & T_{\phi \theta}  & T_{\phi\phi}
\end{array}
\right)
=
\left(
\begin{array}{ccc}
T_{xx} s^2_\theta  + 2 T_{xz}s_\theta c_\theta   + T_{zz}c^2_\theta &
(T_{xx}-T_{zz}) s_\theta c_\theta  + T_{xz} ( c^2_\theta -s^2_\theta  )   &
T_{xy} s_\theta  + T_{zy} c_\theta 
\\
(T_{xx} -T_{zz} )s_\theta c_\theta + T_{xz} (c^2_\theta - s^2_\theta )  &
T_{xx} c^2_\theta  - 2T_{xz}s_\theta c_\theta   + T_{zz}s^2_\theta & 
T_{xy} c_\theta  - T_{zy}  s_\theta 
\\ 
T_{yx} s_\theta  + T_{yz}c_\theta & T_{yx} c_\theta  - T_{yz}s_\theta  & T_{yy}
\end{array}
\right) 
\end{equation}
Note that the trace of this tensor is equal to $T_{xx}+T_{yy}+T_{zz}$ (which is an invariant).

As before we can also use $\sin 2x = 2 \sin x \cos x$ and $\cos 2x = \cos^2 x -\sin^2 x$ 
to simplify the expressions above:
\begin{equation}
\left(
\begin{array}{ccc}
T_{rr}       & T_{r\theta}      & T_{r\phi} \\
T_{\theta r} & T_{\theta\theta} & T_{\theta\phi} \\
T_{\phi r}   & T_{\phi \theta}  & T_{\phi\phi}
\end{array}
\right)
=
\left(
\begin{array}{ccc}
T_{xx} s^2_\theta  +  T_{xz} \sin 2\theta   + T_{zz}c^2_\theta &
\frac12(T_{xx}-T_{zz}) \sin 2\theta  +T_{xz} \cos 2\theta    &
T_{xy} s_\theta  + T_{zy} c_\theta 
\\
\frac12 (T_{xx} -T_{zz} ) \sin 2\theta  + T_{xz} \cos 2 \theta   &
T_{xx} c^2_\theta  - T_{xz} \sin 2\theta  + T_{zz}s^2_\theta & 
T_{xy} c_\theta  - T_{zy}  s_\theta 
\\ 
T_{yx} s_\theta  + T_{yz}c_\theta & T_{yx} c_\theta  - T_{yz}s_\theta  & T_{yy}
\end{array}
\right) 
\end{equation}
or,
\begin{eqnarray}
T_{rr} &=& T_{xx} \sin^2 \theta  +  T_{xz} \sin 2\theta   + T_{zz} \cos^2 \theta \\
T_{\theta\theta} &=& T_{xx} c^2_\theta  - T_{xz} \sin 2\theta  + T_{zz} \sin^2 \theta \\
T_{r\theta} &=& \frac12(T_{xx}-T_{zz}) \sin 2\theta  +T_{xz} \cos 2\theta
\end{eqnarray}
which translates as follows in the code {\color{red} modify code}:
\begin{lstlisting}
def convert_tensor_to_spherical_coords(theta_polar,Txx,Tzz,Txz):
    theta_sph=np.pi/2-theta_polar
    sin_theta=np.sin(theta_sph)
    cos_theta=np.cos(theta_sph)
    Trr=Txx*sin_theta**2 +2*Txz*sin_theta*cos_theta +Tzz*cos_theta**2
    Ttt=Txx*cos_theta**2 -2*Txz*sin_theta*cos_theta +Tzz*sin_theta**2
    Trt=(Txx-Tzz)*sin_theta*cos_theta +Txz*(cos_theta**2-sin_theta**2)
\end{lstlisting}


FLAPS:
\begin{verbatim}
err1[i]=exx1[i]*np.sin(theta[i])**2+2*exz1[i]*np.sin(theta[i])*np.cos(theta[i])+ezz1[i]*np.cos(theta[i])**2
ett1[i]=exx1[i]*np.cos(theta[i])**2-2*exz1[i]*np.sin(theta[i])*np.cos(theta[i])+ezz1[i]*np.sin(theta[i])**2
ert1[i]=(exx1[i]-ezz1[i])*np.sin(theta[i])*np.cos(theta[i])+exz1[i]*(-np.sin(theta[i])**2+np.cos(theta[i])**2)
\end{verbatim}

Remark: We could arrive at $T_{xx}$ also by stating that $T_{rr} = \vec{n} \cdot {\bm T} \cdot \vec{n}$,
where $\vec{n}=(\sin\theta \cos\phi, \sin\theta\sin\phi,\cos\theta)$ is the normal to the sphere surface.
Since we are computing in the $xz$-plane then $\phi=0$ and then 
$\vec{n}=(\sin\theta , 0 ,\cos\theta)$. The calculation above will yield the 
same expression for $T_{rr}$ as before.





\newpage
As mentioned before we assume that deformation takes place in the $x,z$-plane, so that 
derivatives with respect to $y$ and $v_y$ are automatically zero:
\[
\dot{\bm\varepsilon}_{\tiny Cart}
=
\left(
\begin{array}{ccc}
\dot\varepsilon_{xx} & 0 & \dot{\varepsilon}_{xz} \\
0 & \dot{\varepsilon}_{yy}  & 0 \\
\dot{\varepsilon}_{xz} & 0 & \dot\varepsilon_{zz}
\end{array}
\right)
\]
so 
\begin{eqnarray}
\dot{\bm \varepsilon}_{\tiny Sph}=
\left(
\begin{array}{ccc}
\dot\varepsilon_{rr}       & \dot\varepsilon_{r\theta}      & \dot\varepsilon_{r\phi} \\
\dot\varepsilon_{\theta r} & \dot\varepsilon_{\theta\theta} & \dot\varepsilon_{\theta\phi} \\
\dot\varepsilon_{\phi r}   & \dot\varepsilon_{\phi \theta}  & \dot\varepsilon_{\phi\phi}
\end{array}
\right)
&=&
\left(
\begin{array}{ccc}
s_\theta  & 0 & c_\theta \\
c_\theta  & 0 & -s_\theta \\
0 & 1 & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
\dot\varepsilon_{xx} & 0 & \dot{\varepsilon}_{xz} \\
0 & \dot{\varepsilon}_{yy}  & 0 \\
\dot{\varepsilon}_{xz} & 0 & \dot\varepsilon_{zz}
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
s_\theta & c_\theta & 0 \\
0 & 0 & 1 \\
c_\theta & -s_\theta & 0
\end{array}
\right)  \nonumber\\
&=&
\left(
\begin{array}{ccc}
s_\theta  & 0 & c_\theta \\
c_\theta  & 0 & -s_\theta \\
0 & 1 & 0 
\end{array}
\right)
\cdot
\left(
\begin{array}{ccc}
\dot\varepsilon_{xx} s_\theta + 
\dot\varepsilon_{xz} c_\theta  & 
\dot\varepsilon_{xx} c_\theta - 
\dot\varepsilon_{xz} s_\theta  &
0 \\
0 & 0 & \dot{\varepsilon}_{yy}  
\\
\dot\varepsilon_{xz} s_\theta + 
\dot\varepsilon_{zz} c_\theta  &
\dot\varepsilon_{xz} c_\theta - 
\dot\varepsilon_{zz} s_\theta  &
0 
\end{array}
\right)  \nonumber\\
&=&
\left(
\begin{array}{ccc}
\dot\varepsilon_{xx} s_\theta^2 + 
2 \dot\varepsilon_{xz} c_\theta  s_\theta +
\dot\varepsilon_{zz} c_\theta ^2  
& 
\dot\varepsilon_{xx} c_\theta s_\theta - 
\dot\varepsilon_{xz} s_\theta^2  +
\dot\varepsilon_{xz} c_\theta^2 - 
\dot\varepsilon_{zz} s_\theta c_\theta 
& 0 \\ \\
\dot\varepsilon_{xx} s_\theta c_\theta+ 
\dot\varepsilon_{xz} c_\theta^2  -
\dot\varepsilon_{xz} s_\theta^2 -
\dot\varepsilon_{zz} c_\theta s_\theta 
&
\dot\varepsilon_{xx} c_\theta^2 - 
2\dot\varepsilon_{xz} s_\theta c_\theta +
\dot\varepsilon_{zz} s_\theta^2  
& 0 
\\ \\
0 & 0 & \dot{\varepsilon}_{yy} 
\end{array}
\right)  \nonumber
\end{eqnarray}



\newpage
%==============================================================================
\section{Pressure normalisation}

When normal velocities are prescribed on all sides of the domain
the computed pressure is not unique (nullspace of size 1). 
One then typically arbitrarily enforce and additional condition
on the pressure field (in a postprocessing step), typically 'average surface pressure is zero'
or 'volume average is zero'. 

In what follows we make the assumption that all elements are identical, 
i.e. no mesh stretching. 

%-----------------------------------------
\subsection{Plane strain - volume average}

In this case the volume average is simply:
\[
<p> = \frac{\iint p \; dV}{\iint\; dV} = \frac{\sum_e \iint_{\Omega_e} p \; dV }{\sum_e \iint_{\Omega_e} \; dV}
\]
which simply translates as follows: 
\begin{lstlisting}
pressure_avrg=0
for iel in range(0,nel):
    for iq in range(0,nqel):
        pressure_avrg+=np.dot(N_P[iq,:],p[icon_P[:,iel]])*JxWq[iel,iq]
pressure_avrg/=volume
\end{lstlisting}
This works equally well for Cartesian and Annulus domains.




%-----------------------------------------
\subsection{Plane strain - surface average}

Let us assume that the surface in question is the top surface.
\begin{equation}
<p> = \frac{\int p \; dS}{\int\; dS} = \frac{\sum_{e,s} \int p \; dS }{\sum_{e,s} \int \; dS}
\label{eq:normp}
\end{equation}
where the sum of elements only only runs on those elements touching the surface.




\subsubsection{Cartesian geometry}
If the geometry is Cartesian this sum is trivial and runs over the \lstinline{nelx} elements
at the top of the domain.
The integral over the top edge can be approximated by a 1-point quadrature\footnote{Pressure is $Q_1$}
so that 
\[
\int_{edge} p \; dS %= \int_{x_3}^{x_2} \frac12 (p_2 + p_3) dx 
= \frac{x_2-x_3}{2} (p_2 + p_3)
= \frac{h_x}{2} (p_2 + p_3)
\]
since the dof layout of the pressure grid is as follows
\begin{verbatim}
3--2
|  |
0--1
\end{verbatim}
In the end we see that the denominator in Eq.~\eqref{eq:normp} is equal to $L_x$ and then
\[
<p> 
= \frac{1}{L_x} \sum_{e,s} \frac{h_x}{2} (p_{e,2} + p_{e,3}) 
= \frac{1}{nelx} \sum_{e,s} \frac12 (p_{e,2} + p_{e,3}) 
\]

\subsubsection{Annulus geometry}

We here consider a half-annulus for simplicity.
The approach is similar, except that the edge length can be seen as being $R_{outer} h_\theta$ long, 
where $h_\theta$ is the angular opening of the element, so that 
\[
\int_{edge} p \; dS %= \int_{\theta_3}^{\theta_2} \frac12 (p_2 + p_3) R d\theta
= \frac12 (p_2 + p_3) R_{outer} (\theta_2-\theta_3)
\]
Then in the end, since the denominator in Eq.~\eqref{eq:normp} is equal to $\pi R_{outer}$
\[
<p>= \frac{1}{\pi R_{outer}} \sum_{e,s} \frac{R_{outer}}{2} (p_{e,2} + p_{e,3})  (\theta_{e,2}-\theta_{e,3})
= \frac{1}{\pi} \sum_{e,s} \frac12 (p_{e,2} + p_{e,3})  (\theta_{e,2}-\theta_{e,3})
\]






%------------------------
\subsection{Axisymmetric}

\subsubsection{Cartesian geometry}

Although technically possible, the axisymmetric approximation 
is not implemented for Cartesian geometries.

\subsubsection{Annulus geometry}

In spherical coordinates, the surface element is $dS=R_{outer}^2 \sin \theta_s \; d\theta_s d\phi$ 
(we here use the subscript 's' to indicate that this is the $\theta$ angle of the spherical coordinates).

\[
<p> 
= \frac{\iint p(\theta_s,\phi) dS }{\iint dS}
= \frac{\iint p(\theta_s,\phi) R_{outer}^2 \sin \theta_s d\theta_s d\phi}{\iint R_{outer}^2 \sin \theta_s d\theta_s d\phi}
\]
and since $p$ is independent of $\phi$ then 
\[
<p> 
%= \frac{R_{outer}^2  2\pi  \int_0^\pi p(\theta_s)  \sin \theta_s d\theta_s} {4\pi R_{outer}^2}
= \frac{ 2\pi R_{outer}^2 \int_0^\pi p(\theta_s)  \sin \theta_s d\theta_s} {4\pi R_{outer}^2}
=\frac{  \int_0^\pi p(\theta_s)  \sin \theta_s d\theta_s} {2}
\]
The integral over $\theta_s$ can be simplified by using the average pressure 
along the edge and the angle of the edge middle point:
\[
\int_0^\pi p(\theta_s) \sin\theta_s d\theta_s 
= \sum_{e,s} \int_{\theta_{s,e,3}}^{\theta_{s,e,2}} p(\theta_s) \sin\theta_s d\theta_s
\simeq \sum_{e,s} \frac12(p_{e,2}+p_{3,e}) \sin \frac{\theta_{s,e,2}+\theta_{s,e,3} }{2} (\theta_{s,e,2} -\theta_{s,e,3} )
\]
Remember that the sum runs over all elements ('e') at the surface ('s').
In the end
\[
<p> = \frac12 \sum_{e,s}  \frac12(p_{e,2}+p_{3,e}) \sin \frac{\theta_{s,e,2}+\theta_{s,e,3} }{2} (\theta_{s,e,2} -\theta_{s,e,3} )
\]
Note again that this is valid for $\theta_s$, not $\theta_p$, so that we will need to convert to $\theta_s$ in the 
code:
\[
\frac{\theta_{s,e,2}+\theta_{s,e,3} }{2} 
= \frac12 ( \frac{\pi}{2} - \theta_{p,e,2} + \frac{\pi}{2} - \theta_{p,e,3}  )
= \frac{\pi}{2} - \frac{1}{2} ( \theta_{p,e,2} +  \theta_{p,e,3}  )
\]
and 
\[
\theta_{s,e,2} -\theta_{s,e,3} 
= \frac{\pi}{2} - \theta_{p,e,2} - \frac{\pi}{2} + \theta_{p,e,3}
= \theta_{p,e,3} - \theta_{p,e,2}
\]


%\begin{lstlisting}
%poffset/=4*np.pi*R2**2
%\end{lstlisting}

















\newpage
%==============================================================================
\section{Generic mass, momentum, energy conservation equations}

We focus on the system of equations in a $d=2$- or $d=3$-dimensional
domain $\Omega$ that describes the motion of a highly viscous fluid (i.e.
near infinite Prandlt number) driven
by differences in the gravitational force due to a density variations. 
In the following, we largely follow the exposition of this
material in Schubert, Turcotte and Olson \cite{scto01}.

\[
{\bm \sigma} = -p \; {\bm 1} + {\bm \tau}
\]
\[
{\bm \tau} = 2 \eta \dot{\bm \varepsilon}^d(\vec\upnu) = 2\eta \left(\dot{\bm \varepsilon}(\vec \upnu)
                                  - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
\]


Specifically, we consider the following set of equations for 
velocity $\vec\upnu$, pressure $p$ and temperature $T$:
\begin{align}
  \label{eq:stokes-1}
  - \vec\nabla p +  
  \vec\nabla \cdot \left[2\eta \left(\dot{\bm \varepsilon}(\vec \upnu)
                                  - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
                \right] +  \rho \vec g &= \vec{0}
  &
  & \textrm{in $\Omega$},
  \\
  \label{eq:stokes-2}
  \frac{\partial \rho}{\partial t} + \vec\nabla \cdot (\rho \vec \upnu) &= 0
  &
  & \textrm{in $\Omega$},
  \\
  \label{eq:temperature}
  \rho C_p \left(\frac{\partial T}{\partial t} + \vec \upnu\cdot\vec\nabla T\right)
  - \vec\nabla\cdot k\vec\nabla T
  &=
  \rho H
  \notag
  \\
  &\quad
  +
  2\eta
  \left(\dot\varepsilon(\vec\upnu) - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
  :
  \left(\dot\varepsilon(\vec\upnu) - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
  \\
  &\quad
  %+\alpha T \left( \vec \upnu \cdot \vec\nabla p \right)
  +\alpha T \left( \frac{\partial p}{\partial t} +  \vec \upnu \cdot \vec\nabla p \right)
  && \textrm{in $\Omega$},
\end{align}
where $\dot{\bm \varepsilon}(\vec\upnu) = \frac{1}{2}(\vec\nabla \vec\upnu + \vec\nabla \vec\upnu^T)$
is the symmetric gradient of the velocity (often called the
\textit{strain rate} tensor).

In this set of equations, \eqref{eq:stokes-1} and \eqref{eq:stokes-2}
represent the compressible Stokes equations in which $\vec\upnu =\vec\upnu (\mathbf x,t)$
is the velocity field and $p=p(\mathbf x,t)$ the pressure
field. Both fields depend on space $\mathbf x$ and time $t$. Fluid flow is
driven by the gravity force that acts on the fluid and that is proportional to
both the density of the fluid and the strength of the gravitational pull.

Coupled to this Stokes system is equation \eqref{eq:temperature} for the
temperature field $T=T(\mathbf x,t)$ that contains heat conduction terms as
well as advection with the flow velocity $\vec{\upnu}$. The right hand side
terms of this equation correspond to
\begin{itemize}
\item internal heat production for example due to radioactive decay;
\item friction (shear) heating;
\item adiabatic compression of material;
\end{itemize}



\subsubsection{A word about the shear heating term}
It is defined as
\[
\Phi=2 \eta
\left(\dot\varepsilon(\vec\upnu) - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
:
\left(\dot\varepsilon(\vec\upnu) - \frac{1}{3}(\vec\nabla \cdot \vec \upnu)\mathbf 1\right)
\]
We start from the 3d strain rate tensor 
\[
\dot{\bm \varepsilon}(\vec\upnu) = 
\left(
\begin{array}{ccc}
\dot{\varepsilon}_{xx} & \dot{\varepsilon}_{xy} & \dot{\varepsilon}_{xz} \\
\dot{\varepsilon}_{yx} & \dot{\varepsilon}_{yy} & \dot{\varepsilon}_{yz} \\
\dot{\varepsilon}_{zx} & \dot{\varepsilon}_{zy} & \dot{\varepsilon}_{zz} 
\end{array}
\right)
\]

The plane strain assumption is such that the problem at hand is assumed to be  
infinite in a given direction. In the case of computational geodynamics, most 2D  
modelling is a vertical section of the crust-lithosphere-mantle
and the underlying implicit assumption is then that the orogen/rift/subduction/etc ... 
is infinite in the direction perpendicular to the screen/paper.  

Let us assume that the deformation takes place in the $x,z$-plane,
so that $v=0$ (velocity in the $y$ direction is zero) and $\partial_y \rightarrow 0$ 
(no change in the $y$ direction).
We then have $\dot{\varepsilon}_{yy}=0$ as well as $\dot{\varepsilon}_{xy}=0$ 
and $\dot{\varepsilon}_{yz}=0$, so that the strain rate tensor is  
\[
\dot{\bm \varepsilon}(\vec\upnu)=
\left( \begin{array}{ccc}
\dot{\varepsilon}_{xx} & 0 & \dot{\varepsilon}_{xz} \\
0 & 0 & 0  \\
\dot{\varepsilon}_{xz} & 0 & \dot{\varepsilon}_{zz} 
\end{array}\right)
\]
where we have also used the fact that the tensor is symmetric.
The deviatoric strain rate tensor in plane strain is given by
\[
\dot{\bm \varepsilon}^d(\vec\upnu) 
= \dot{\bm \varepsilon}(\vec\upnu) -\frac{1}{3} {\rm tr}[\dot{\bm \varepsilon}]   {\bm 1} 
= \dot{\bm \varepsilon}(\vec\upnu) -\frac{1}{3} (\dot{\varepsilon}_{xx} +\dot{\varepsilon}_{zz}   )  {\bm 1} 
=
\left(
\begin{array}{ccc}
\frac{2}{3}\dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & \dot{\varepsilon}_{xy} & 0 \\
\dot{\varepsilon}_{yx} & -\frac{1}{3} \dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & 0 \\
0 & 0 & -\frac{1}{3}\dot{\varepsilon}_{xx} +\frac{2}{3} \dot{\varepsilon}_{zz} 
\end{array}
\right)
\]
We then have
\begin{eqnarray}
&&\dot{\bm \varepsilon}^d(\vec\upnu) : \dot{\bm \varepsilon}^d(\vec\upnu) \nn\\
&=& 
\left(
\begin{array}{ccc}
\frac{2}{3}\dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & \dot{\varepsilon}_{xy} & 0 \\
\dot{\varepsilon}_{yx} & -\frac{1}{3} \dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & 0 \\
0 & 0 & -\frac{1}{3}\dot{\varepsilon}_{xx} +\frac{2}{3} \dot{\varepsilon}_{zz} 
\end{array}
\right)
:
\left(
\begin{array}{ccc}
\frac{2}{3}\dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & \dot{\varepsilon}_{xy} & 0 \\
\dot{\varepsilon}_{yx} & -\frac{1}{3} \dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} & 0 \\
0 & 0 & -\frac{1}{3}\dot{\varepsilon}_{xx} +\frac{2}{3} \dot{\varepsilon}_{zz} 
\end{array}
\right) \nn\\
&=&
\left(\frac{2}{3}\dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} \right)^2 
+ 
\left(-\frac{1}{3} \dot{\varepsilon}_{xx} -\frac{1}{3}\dot{\varepsilon}_{zz} \right)^2 
+ 
\left(-\frac{1}{3}\dot{\varepsilon}_{xx} +\frac{2}{3} \dot{\varepsilon}_{zz} \right)^2 
+ 2  \dot{\varepsilon}_{xz}^2 
\nn\\
&=& (\frac49 +\frac19 +\frac19) \dot{\varepsilon}_{xx}^2 + 
(\frac19 + \frac49 + \frac19 )\dot{\varepsilon}_{zz}^2 
+(-\frac29 -\frac29 +\frac19) \dot{\varepsilon}_{xx} \dot{\varepsilon}_{zz} 
+ 2  \dot{\varepsilon}_{xz}^2 \nn\\
&=&  \frac23  \dot{\varepsilon}_{xx}^2 + 
\frac23 \dot{\varepsilon}_{zz}^2 
-\frac13  \dot{\varepsilon}_{xx} \dot{\varepsilon}_{zz} 
+ 2  \dot{\varepsilon}_{xz}^2 
\end{eqnarray}

This translates as follows in the code:
\begin{lstlisting}
b_el[:]+=N[:]*JxWq[iq]*2*etaq[iel,iq]*\
       (2./3.*(exxq[iel,iq]**2+ezzq[iel,iq]**2)\
       -exxq[iel,iq]*ezzq[iel,iq]/3+2*exzq[iel,iq]**2)
\end{lstlisting}

\newpage
%==============================================================
\section{Equation of state}

%taken from mayu07
The equation of state gives the density as a function of the
pressure and temperature: $\rho=\rho(p,T)$.
The density is then either obtained from precomputed lookup
tables or a simpler functional approach is often taken
by means of a linearisation.

The widely used Boussinesq approximation (see below) linearizes these
basic conservation laws near the reference hydrostatic state.
If density changes caused by the pressure deviations
$p' = p-p_0$ are neglected, we may linearize the state equation with respect to
the temperature deviations $T-T_0$, where $T_0$ is a reference
temperature, and write:
\[
\rho=\rho_0(1-\alpha(T-T_0))
\]
This approximation thus means that the influence of hydrostatic pressure 
(as well as temperature $T_0$) on density is hidden
in a spatial dependence of the reference density $\rho_0$.

The reference density $\rho_0$ is assumed to be a time-independent function. 
Considering only the largest term in the equation of continuity, that is, 
neglecting thermal expansion, we arrive at the simplified equation:
\[
\vec\nabla\cdot(\rho_0 \vec\upnu) =0
\]


\newpage
%==============================================================
\section{Anelastic liquid approximation (ALA)}

This comes from \textcite{mayu07}.

If we assume that there is a reference hydrostatic state characterized 
by $\vec\upnu = 0$ in which the hydrostatic pressure $p_0$, 
hydrostatic density $\rho_0$, and hydrostatic gravity acceleration $g_0$ are
related by $\vec\nabla p_0 = \rho_0 \vec{g}_0$,
and moreover that pressure deviations $p'=p-p_0$
are negligible in the heat equation, the transfer of heat in a homogeneous
material (i.e., entropy may be considered as a function of only
p and T) is then described by the well-known equation:
\[
\rho C_p \left( \frac{\partial T}{\partial t} + \vec \upnu\cdot\vec\nabla T\right)
=  \vec\nabla\cdot k\vec\nabla T  
- \alpha T  \vec\upnu \cdot \rho \vec{g} 
+ {\bm \tau} : \vec\nabla \vec\upnu + Q
\]
where $C_p$ is the isobaric specific heat, $\alpha$ is the thermal expansion
coefficient and vr denotes the radial component of velocity. The
left-hand side of equation 8 represents local changes of heat balance; 
the second (third) term on the right-hand side describes ad-
vection of heat (adiabatic heating and/or cooling).



\newpage
%==============================================================
\section{Boussinesq approximation (BA)}

In the case of an incompressible flow, then $\partial \rho/\partial t=0$ and
${\vec \nabla}\rho=0$, i.e. $D\rho/Dt=0$ and the mass conservation equation becomes:
\[
{\vec \nabla}\cdot{\vec \upnu} = 0
\]
A vector field that is divergence-free is also called
solenoidal\footnote{\url{https://en.wikipedia.org/wiki/Solenoidal_vector_field}}.

In this case the equations above can now be written

\begin{align}
  - \vec\nabla p +  
  \vec\nabla \cdot \left[2\eta \left(\dot{\bm \varepsilon}(\vec \upnu)  \right)
                \right] +  \rho \vec g &= \vec{0}
  &
  & \textrm{in $\Omega$},
  \\
  \vec\nabla \cdot \vec \upnu &= 0
  &
  & \textrm{in $\Omega$},
  \\
  \rho C_p \left(\frac{\partial T}{\partial t} + \vec \upnu\cdot\vec\nabla T\right)
  - \vec\nabla\cdot k\vec\nabla T
  &=
  \rho H
  +
  2\eta \dot\varepsilon(\vec\upnu) : \dot\varepsilon(\vec\upnu) 
  %+\alpha T \left( \vec \upnu \cdot \vec\nabla p \right)
  +\alpha T \left( \frac{\partial p}{\partial t} +  \vec \upnu \cdot \vec\nabla p \right)
  && \textrm{in $\Omega$},
\end{align}

\noindent As nicely explained in \textcite{spve60}: 
\begin{displayquote}
{\color{darkgray}
In the study of problems of thermal convection it is a frequent practice to simplify the basic 
equations by introducing certain approximations which are attributed to
Boussinesq (1903). The Boussinesq approximations can best be summarized by two
statements: 
\begin{enumerate}
\item The fluctuations in density which appear with the advent of motion
result principally from thermal (as opposed to pressure) effects. 
\item In the equations
for the rate of change of momentum and mass, density variations may be neglected except
when they are coupled to the gravitational acceleration in the buoyancy force."
\end{enumerate}
}
\end{displayquote}
Note that their paper examines the Boussinesq approximation for compressible fluids.  

The Boussinesq approximation assumes that the density can be
considered constant in all occurrences in the equations with the exception of
the buoyancy term on the right hand side of \eqref{eq:stokes-1}. The primary
result of this assumption is that the continuity equation \eqref{eq:stokes-2}
will now read ${\vec \nabla}\cdot{\vec \upnu} = 0$.
This implies that the strain rate tensor is deviatoric.
Under the Boussinesq approximation, the equations are much simplified:

\begin{align}
  -\vec\nabla p + \vec\nabla \cdot \left[2\eta \dot{\bm \varepsilon}(\vec\upnu) \right] + \rho \vec{g} &= \vec{0}
  &
  & \textrm{in $\Omega$},  \\
  \vec\nabla \cdot  \vec\upnu &= 0 
  &
  & \textrm{in $\Omega$},
  \\
  \rho_0 C_p \left(\frac{\partial T}{\partial t} + \vec\upnu \cdot\vec\nabla T\right)
  - \vec\nabla\cdot k\vec\nabla T
  &=
  \rho H
  &
  & \textrm{in $\Omega$}
\end{align}
Note that all terms on the rhs of the temperature equations have disappeared, with the exception 
of the source term.

In \textcite{vacp22} we read: 
\begin{displayquote}
The Boussinesq approximation (\textcite{ober79}; Boussinesq, 1903; Rayleigh, 1916) 
assumes that density
variations are so small that they can be neglected everywhere
except in the buoyancy term in the momentum equation, 
which is equivalent to using a constant reference density profile. 
This implies incompressibility [...]. In addition, adiabatic heating
and shear heating are not considered in the energy equation. 
This approximation is valid as long as density variations are small 
and the modelled processes would cause no substantial 
shear or adiabatic heating.
The Boussinesq approximation is often used in lithosphere-
scale models. Due to its simplicity, the approximation of in-
compressibility is sometimes also adopted for whole-mantle
convection models, wherein it is only approximately valid,
and it has been shown that compressibility can have a large
effect on the pattern of convective flow \cite{tack96}.
\end{displayquote}





\newpage
%==============================================================
\section{Extended Boussinesq approximation (EBA)}

In \textcite{vacp22} we read: 
\begin{displayquote}
The extended Boussinesq approximation (\cite{chyu85,oxtu78}) is based
on the same assumptions as the BA but does consider adiabatic 
and shear heating. Since it includes adiabatic heating,
but not the associated volume and density changes, it can
lead to artificial changes of energy in the model, i.e. material 
is being heated or cooled based on the assumption that
it is compressed or it expands, but the mechanical work that
causes compression or expansion is not done. Consequently,
the extended Boussinesq approximation should only be used
in models without substantial adiabatic temperature changes.

For a comparison between some of these approximations
using benchmark models, see e.g. \textcite{sthe89},
\textcite{lezh08}, \textcite{kilv10}, \textcite{gadb20}. 
In addition, the choice of approximation may
also be limited by the numerical methods being employed
(for example, the accuracy of the solution for the variables
that affect the density). Also note that, technically, these 
approximations are all internally inconsistent to varying 
degrees, since they do not fulfil the definitions of
thermodynamic variables but use linearised versions instead,
and they use different density formulations in the different 
equations. Nevertheless, many of them are generally accepted 
and widely used in geodynamic modelling studies, as
they allow for simpler equations and more easily obtained solutions.
\end{displayquote}


%==============================================================================
\section{Computing the lithostatic pressure}


%==============================================================================
\section{Initial adiabatic temperature profile}




%==============================================================================
\section{Dynamic topography}


%==============================================================================
%\section{Computing the gravity field}


\newpage
\section{Notes}
%-----------------------------
\subsection{Plane strain case}

\begin{lstlisting}
ggx=0.
ggy=0.
for iel in range(0,nel):
    xx=xs-xc[iel]
    yy=ys-yc[iel]
    rr=np.sqrt(xx**2+yy**2)
    ggx+=Ggrav*(rho[iel]-rho_ref)*vol[iel]*xx/rr**3
    ggy+=Ggrav*(rho[iel]-rho_ref)*vol[iel]*yy/rr**3
gnorm=np.sqrt(ggx**2+ggy**2)
\end{lstlisting}


%-----------------------------
\subsection{Axisymmetric case}

Although the FEM calculations take place in the $xz$-plane, we need to think 
of the system as a 3d one, i.e. the half annulus mass distribution is repeated
from $\phi=0$ to $\phi=2\pi$. Each element we consider must be seen as a torus 
whose cross section is the element under consideration.

Let us assume that the satellite is at position $(x_s,y_s,z_s)$.
Let us for now isolate a single element $e$ of surface $S_e$ and $\phi-$angular 
opening $\delta\phi$, and density $\rho_e$ with 
its center of mass at position $(x_e,y_e,z_e))$.
The gravity that the element mass exerts on the satellite is a vector with components
\begin{align}
g_x (x_s,y_s,z_s,e) &= {\cal G} \frac{S_e \rho_e \delta\phi}{[(x_s-x_e)^2+(y_s-y_e)^2+(z_s-z_e)^2]^{3/2}} (x_s-x_e)\\
g_y (x_s,y_s,z_s,e) &= {\cal G} \frac{S_e \rho_e \delta\phi}{[(x_s-x_e)^2+(y_s-y_e)^2+(z_s-z_e)^2]^{3/2}} (y_s-y_e)\\
g_z (x_s,y_s,z_s,e) &= {\cal G} \frac{S_e \rho_e \delta\phi}{[(x_s-x_e)^2+(y_s-y_e)^2+(z_s-z_e)^2]^{3/2}} (z_s-z_e)
\end{align}


\begin{center}
\includegraphics[width=5cm]{IMAGES/sphcoord}
\end{center}

We can rewrite the position of the element center in spherical coordinates ollows:
\begin{eqnarray}
x_e &=& r_e \sin \theta_e \cos \phi_e \\
y_e &=& r_e \sin\theta_e \sin\phi_e \\
z_e &=& r_e \cos\theta_e 
\end{eqnarray}
In this case $\theta\in[0:\pi]$ and $\phi\in]-\pi:\pi]$ and we have the following relationships:
Let us focus on $g_x$ for now.
\begin{align}
g_x (x_s,y_s,z_s,e) 
&= {\cal G} \frac{S_e \rho_e \delta\phi}{[(x_s-x_e)^2+(y_s-y_e)^2+(z_s-z_e)^2]^{3/2}} (x_s-x_e) \nonumber\\
&= {\cal G} \frac{S_e \rho_e \delta\phi}{[
(x_s-r_e \sin \theta_e \cos \phi_e)^2+
(y_s-r_e \sin\theta_e \sin\phi_e)^2+
(z_s-r_e \cos\theta_e)^2]^{3/2}} (x_s-r_e \sin \theta_e \cos \phi_e) \nonumber
\end{align}
At this stage we must acknowledge that inside the torus $r_e$ and $\theta_e$ are constant 
and only the $\phi_e$ value changes. Since the position of the satellite is assumed 
to be fixed for now then the last term of the denominator $(z_s-r_e \cos\theta_e)$ is then a constant.
Likewise, since the domain is a half-annulus and we only consider the center of mass of element
then we have $r_e>0$  and $\theta_e>0$ and $\theta_e<\pi$ so that $r_e \sin\theta_e >0$.
We can then define:
\[
x_s' = \frac{x_s}{r_e \sin\theta_e} \qquad
y_s' = \frac{y_s}{r_e \sin\theta_e} \qquad
z_s' = \frac{z_s}{r_e \sin\theta_e} 
\]

We can then write:
\begin{align}
g_x (x_s,y_s,z_s,e) 
&= \int_0^{2\pi} \frac{\cal G}{r_e\sin\theta_e} \frac{S_e \rho_e }{[
(x'_s- \cos \phi)^2+
(y'_s- \sin\phi)^2+
(z'_s- \tan^{-1} \theta_e)^2]^{3/2}} 
(x'_s- \cos \phi)   d\phi \nonumber
\end{align}
We then find ourselves having to compute and integral of the form:
\[
\int_0^{2\pi} \frac{a -\cos\phi}{[(a-\cos\phi)^2 + (b-\sin\phi)^2 +c^2 ]^{3/2}} d\phi
\]

\newpage

In \cite{budt14} we find

``We employ a temperature- and depth-dependent rheology of
the non-dimensional form:
\[
\eta(T,z) = \eta_r(z) \exp (A(0.5-T))
\]
where $\eta_r(z)=1$ for $z<663$km and $\eta_r(z)=0.1225z-51.2$ for
$663 \le z \le 2867$km. 
$\eta$ and $z$ are the non-dimensional viscosity and dimensional depth respectively.
[...] it leads to a weak upper mantle, a $30\times$ viscosity step at the boundary 
between the upper and lower mantle, and a $10\times$ linear increase with depth to the base of
the mantle. The non-dimensional activation coefficient is chosen
to be $A=9.2103$, which leads to a temperature-induced viscosity contrast of $10^4$.
''

This is a beautiful example of reviewing/editing failure. The above equation 
is clearly formulated for dimensionless quantities, but the $\eta_r(z)=0.1225z-51.2$
only makes sense if $z$ is expressed in km. 
Likewise the value 2867km is surprisingly off with regards to the agreed upon 
cmb depth of about 2890km. Finally the real outer radius of the domain is never specified, 
and neither are the temperature boundary conditions.

At 663km depth we find $\eta_r(z)=0.1225*663-51.2=30$ 
and at 2867km depth we find $\eta_r(z)=0.1225*2867-51.2=300$, so this adds 
up with respect to the text.

In the end, if we want to use this rheology in an Earth-dimensioned model
we will need to use
\[
\eta(T,z) = \eta_0 \eta_r(z) \exp (A(0.5-T))
\]
where $\eta_0\sim 10^{21}$ .


\section{TO DO}

- which is the correct way of computing DT? remove average stress, or removing average pressure only?

- test

- vrms in axisymmetry

- check dev strain rate in axisymm 
 
- top\_element vs top\_nodeS

- when element is empty , stop AND create vtu file 

- run schmeling subduction - 

- if ss detected make sure vtus are produced 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\printbibliography

\end{document}

